
\newpage
\section{Critical Assessment}\label{sec:discussion}

As demonstrated in the previous chapters, partial evaluation as a technology has applications in many fields of programming and computer science.
The use of partial evaluation in software development would allow developers to create a single general program, that could then be specialized to a fixed problem domain.
This way, development costs could be reduced as it is only necessary to develop and maintain a single application, or existing programs depending on a fixed configuration could be optimized.
Often cited examples for the second case are web servers, which are dependent on a configuration file or the specialization of a renderer to a fixed scene~\cite{Jones_PartialEvaluation}.

Nevertheless, partial evaluation is not widespread and its use is often limited to research areas.
The focus of existing specializers is often the exploration of new strategies and possibilities rather than user experience~\cite{Cook_TutorialOnlinePartialEvaluation}.
Additionally, partial evaluation does not provide a one-size-fits-all solution, as the two common approaches online and offline partial evaluation both come along with advantages and disadvantages.
Online partial evaluation generally has the capability to produce more optimized residual programs.
It is, however, not always applicable, as the specialization will not always halt if its inputs are not restricted.
Offline partial evaluation, on the other hand, makes it easier to ensure termination, as the division is computed during the separate binding time analysis and not \enquote{on the fly}.
At the same time it generally yields less optimized residual programs.
The gains of optimization are with both cases hard to predict and largely dependent on the concrete input~\cite{Sumii_HybridApproach}.

It is unlikely, that the use of partial evaluators and interpreters as an alternative to traditional compiler construction will be widespread.
While the creation of a compiler from a partial evaluator and an interpreter looks easy in theory, in practice the effort of constructing a partial evaluator and an interpreter is not substantially smaller than the effort of constructing a single compiler.
Additionally, the right combination of implementation, input and output languages is required to make this way of compilation useful, as normally compilers are used to generate low-level machine code.

Even if this way of constructing compilers would become widespread, classical compiler construction would still be relevant.
All optimizations a partial evaluator and a compiler created from it can use, have to be implemented at first.
Efficient data structures, mathematical simplifications and clever use of available hardware are not created \enquote{from nothing}.
A partial evaluator will only use existing structures within itself, an interpreter or the source program and thus, human ingenuity is required to create truly efficient programs.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
