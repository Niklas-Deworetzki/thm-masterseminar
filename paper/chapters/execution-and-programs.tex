
\section{Execution of Programs}\label{chap:programs}

% Usually execution of programs is seen as a single, atomic step of computation.
% Programs solving computational program are executed, accepting input, producing output. (Figure)
% In reality programs often can't be excuted directly.
% Programs accepting programs are used to transform into executable form. (Meta programs)
% Three forms of meta programs are presented: Interpreters and compilers, mostly known
% Finally PE in  order to categorize.

Programs are implementations of algorithms, which are used to solve computational problems.
In contrast to algorithms, programs handle details as acquiring inputs, producing outputs, structuring memory and other tasks, that are required in order to be executed by a machine.

Figure~\ref{fig:native-program} shows a schematic representation of how a program is used to solve a computational problem.
The program accepts inputs and produces an output, both of which are represented by oval shapes, with arrows describing their relationship with the program.
As it can be seen, a single program may accept many inputs, allowing it to handle as many cases of the computational problem and producing an output in each of these cases.
Naturally with the capability of reading, distinguishing and validating different inputs, the complexity of a program grows.
But as figure~\ref{fig:native-program} also shows, the execution occurs as a single computational stage, regardless of the required resources.

In reality, however, it is often not possible to directly execute a program, as the language it is written is can not be executed by a computer.
Computers are limited in that they can only execute instructions, that are described in a low-level machine language.
Programs on the other hand are usually written in a higher-level language, since the abstractions provided by this language allows a better description of the required instructions.
In order to execute such a program, written in a higher language, a translation has to be performed.
The tedious task of translating programs can be performed manually.
But it turns out, that translating a program is also a computational problem, that can automatically be solved by a program.
These programs, that accept other programs as an input in order to solve computational problems, are called meta-programs.
In this paper, three different variants of meta-programs are relevant as they show different ways of how this transformation can be done and how the execution of a program can be achieved.
Starting with interpreters and compilers, a fundamental understanding on the execution of programs is provided, before partial evaluators are introduced.

\begin{figure}
  \centering
% TODO
  \caption{Direct execution of a program}\label{fig:native-program}
\end{figure}



\subsection{Interpreters}

Interpreters are meta programs that execute other programs.
The program to be executed is passed as an input to the interpreter, which is then analyzed and usually transformed into an intermediate representation.
This tree-like structure mirrors the structure and contents of the program.
By assigning a meaning to every node of this tree, a program becomes executable by traversing the tree and performing actions according to the assigned meaning.
Now, given that the interpreter can be executed, programs written in a language, the interpreter can accept as an input, can be executed too.
As Figure~\ref{fig:interpreted-program} shows, the interpreted execution of a program looks very similar as the direct, native execution.
The only difference is, that the program to be executed is now itself along with its inputs passed as an input to the interpreter.
Execution this way is still a single computational stage.

Interpreters provide a simple solution to execute programs in another language and are relatively easy to implement.
On the downside, execution via an interpreter provides less performance, as interpreter and interpreted program share the same resources and some computational overhead is required for analysis of said program.

\begin{figure}
  \centering
% TODO
  \caption{An interpreter executing a program}\label{fig:interpreted-program}
\end{figure}


\subsection{Compilers}

Compilers, similar to interpreters, are programs that are used to transform other programs.
While an interpreter uses the intermediate representation of a program to directly executed the assigned meaning to it, a compiler translates it into another language.
As a result, a compiler produces a single output, which is the so-called target program.
This program holds the meaning of the input program translated into another language.
As seen in Figure~\ref{fig:compiled-program}, this way an additional stage of computation is introduced, since the target program has to be executed, to accept inputs and produce an output like the original program.

As already apparent visually, the translation process of a compiler is more complex than the process of an interpreter.
Since the input program has to be only analyzed once and the target program is executed as a standalone program, compilation usually provides a better performance in contrast to interpretation.
This is especially true, if the same program is executed multiple times, since no computational overhead is present during the execution of the target program, after is has been created once.

\begin{figure}
  \centering
% TODO
  \caption{A compiler generating an executable target program}\label{fig:compiled-program}
\end{figure}



\subsection{Partial Evaluators}

Partial evaluators, as the third meta program introduced and focus of the following paper, generalize the concept of splitting computational stages that has been introduced by compilers.
The inputs of a partial evaluator are a source program as well as some inputs for this program.
Given these inputs, a partial evaluator will perform all computations of the source that are available under the given inputs.
As not all inputs for the source program are present, some computations cannot be performed.
These computations form a so-called residual program, the output of a partial evaluator.

While Figure~\ref{fig:partial-evaluated-program} is structurally similar to Figure~\ref{fig:compiled-program} describing a compiler, the concept is generalized.
A compiler only splits overhead of analysis and the actual computation into different computational stages.
A partial evaluator can split calculations depending on different input into different computational stages.
This way, a general program accepting multiple inputs can be specialized to a fixed input, which usually leads a higher performance, since the overhead of recognizing inputs are removed.

\begin{figure}
  \centering
% TODO
  \caption{A partial evaluator generating a residual program}\label{fig:partial-evaluated-program}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
